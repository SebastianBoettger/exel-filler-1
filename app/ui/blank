from __future__ import annotations

from typing import Dict, List, Optional
import pandas as pd

from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QComboBox, QSpinBox,
    QMessageBox, QFileDialog, QAbstractItemView, QTableWidgetItem,
    QDialog, QFormLayout, QListWidget, QListWidgetItem, QLineEdit, QToolButton
)
from PySide6.QtCore import Qt

from app.services.excel_io import list_sheets, load_table
from app.services.matcher import MatchEngine  # still used for queue (missing fields)
from app.services.normalize import is_missing
from app.services.settings import AppSettings, load_settings, save_settings
from app.services.multi_matcher import MultiMatcher, MatchProfile
from app.services.apply_changes import save_filled, save_to_path, save_in_place
from app.services.transforms import split_street_house, normalize_phone, state_from_zip_de

from app.ui.dnd_tables import TargetTable
from app.ui.source_panel import SourcePanel, SourceState


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Excel-Filler GUI")

        self.settings: AppSettings = load_settings()

        self.t1 = None
        self.t1_df: Optional[pd.DataFrame] = None
        self.engine: Optional[MatchEngine] = None  # used for queue scanning
        self.multi: Optional[MultiMatcher] = None

        self.keys_queue: List[str] = []
        self.current_pos = -1
        self.current_t1_index: Optional[int] = None

        self._t1_cols_top: List[str] = []
        self._t1_cols_bottom: List[str] = []

        # --- central ---
        central = QWidget(self)
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(8)

        # --- T1 file row ---
        top = QHBoxLayout()
        self.btn_t1 = QPushButton("Zieltabelle (T1) wählen")
        self.lbl_t1 = QLabel("—")
        self.lbl_t1.setTextInteractionFlags(Qt.TextSelectableByMouse)
        self.cb_t1_sheet = QComboBox()
        self.sp_t1_header = QSpinBox()
        self.sp_t1_header.setMinimum(1)
        self.sp_t1_header.setValue(1)
        self.cb_t1_key = QComboBox()

        top.addWidget(self.btn_t1)
        top.addWidget(self.lbl_t1, 2)
        top.addWidget(QLabel("Sheet"))
        top.addWidget(self.cb_t1_sheet, 1)
        top.addWidget(QLabel("Header"))
        top.addWidget(self.sp_t1_header)
        top.addWidget(QLabel("KEY (Queue)"))
        top.addWidget(self.cb_t1_key, 1)
        layout.addLayout(top)

        # --- action row ---
        act = QHBoxLayout()
        self.btn_start = QPushButton("Start (fehlende Datensätze finden)")
        self.btn_match = QPushButton("Match-Felder")
        self.btn_prev = QPushButton("◀")
        self.btn_next = QPushButton("▶")
        self.btn_fill_row = QPushButton("Plausibel füllen (Zeile)")
        self.btn_fill_all = QPushButton("Plausibel füllen (Gesamt)")
        self.btn_save_as = QPushButton("Speichern unter…")
        self.btn_save_inplace = QPushButton("Speichern (gleiche Datei)")
        self.btn_save_new = QPushButton("Speichern (neu)")
        act.addWidget(self.btn_start)
        act.addWidget(self.btn_match)
        act.addWidget(self.btn_prev)
        act.addWidget(self.btn_next)
        act.addWidget(self.btn_fill_row)
        act.addWidget(self.btn_fill_all)
        act.addWidget(self.btn_save_as)
        act.addWidget(self.btn_save_inplace)
        act.addWidget(self.btn_save_new)
        layout.addLayout(act)

        # --- search row (T1) ---
        srow = QHBoxLayout()
        self.ed_search_t1 = QLineEdit()
        self.ed_search_t1.setPlaceholderText("Suche in T1 (exakt) …")
        self.btn_search_t1 = QToolButton()
        self.btn_search_t1.setText("Nächstes")
        self.btn_back_t1 = QToolButton()
        self.btn_back_t1.setText("Zurück")
        srow.addWidget(QLabel("T1 Suche:"))
        srow.addWidget(self.ed_search_t1, 2)
        srow.addWidget(self.btn_search_t1)
        srow.addWidget(self.btn_back_t1)
        layout.addLayout(srow)

        # --- T1 2-line views ---
        self.t1_view_top = TargetTable(1, 0)
        self.t1_view_bottom = TargetTable(1, 0)
        for v in (self.t1_view_top, self.t1_view_bottom):
            v.setEditTriggers(QAbstractItemView.DoubleClicked | QAbstractItemView.SelectedClicked | QAbstractItemView.EditKeyPressed)
            v.setDragDropMode(QAbstractItemView.DropOnly)
            v.itemChanged.connect(self.on_t1_item_changed_any)
        layout.addWidget(self.t1_view_top, 3)
        layout.addWidget(self.t1_view_bottom, 2)
        self.t1_view_bottom.hide()

        # --- status ---
        self.status = QLabel("—")
        layout.addWidget(self.status)

        # --- 3 source panels (stacked default) ---
        self.sources: Dict[str, SourcePanel] = {}
        self.src_states = [
            SourceState("src2", "Quelle 2"),
            SourceState("src3", "Quelle 3"),
            SourceState("src4", "Quelle 4"),
        ]

        # Place sources under each other in one dock area:
        # For ergonomics: default bottom area, split vertically.
        self._create_sources_docks()

        # --- events ---
        self.btn_t1.clicked.connect(self.pick_t1)
        self.btn_start.clicked.connect(self.start_scan)
        self.btn_prev.clicked.connect(self.prev_row)
        self.btn_next.clicked.connect(self.next_row)
        self.btn_match.clicked.connect(self.open_match_fields_dialog)

        self.btn_save_new.clicked.connect(self.save_new_file)
        self.btn_save_as.clicked.connect(self.save_as)
        self.btn_save_inplace.clicked.connect(self.save_inplace)

        self.btn_search_t1.clicked.connect(self.search_t1_next)
        self.btn_back_t1.clicked.connect(self.restore_t1_focus)
        self.ed_search_t1.returnPressed.connect(self.search_t1_next)

        self.btn_fill_row.clicked.connect(self.autofill_current_row)
        self.btn_fill_all.clicked.connect(self.autofill_all)

    # ---------- docks ----------
    def _create_sources_docks(self):
        from PySide6.QtWidgets import QDockWidget

        self._source_docks = []
        prev_dock = None

        for st in self.src_states:
            panel = SourcePanel(st, self)

            dock = QDockWidget(st.title, self)
            dock.setWidget(panel)
            dock.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea | Qt.BottomDockWidgetArea)
            dock.setFeatures(QDockWidget.DockWidgetMovable | QDockWidget.DockWidgetFloatable)

            self.addDockWidget(Qt.BottomDockWidgetArea, dock)

            if prev_dock is not None:
                self.splitDockWidget(prev_dock, dock, Qt.Vertical)

            prev_dock = dock
            self._source_docks.append(dock)
            self.sources[st.src_id] = panel

        # optional: gleichmäßige Höhen (best effort)
        try:
            self.resizeDocks(self._source_docks, [250, 250, 250], Qt.Vertical)
        except Exception:
            pass

    # ---------- settings persistence ----------
    def _save_settings(self):
        save_settings(self.settings)

    # ---------- T1 load ----------
    def pick_t1(self):
        path, _ = QFileDialog.getOpenFileName(self, "Zieltabelle (T1) wählen", "", "Excel (*.xlsx *.xls)")
        if not path:
            return
        self.lbl_t1.setText(path)
        self.cb_t1_sheet.clear()
        self.cb_t1_sheet.addItems(list_sheets(path))
        self.cb_t1_sheet.currentTextChanged.connect(lambda: self._reload_t1(path))
        self._reload_t1(path)

    def _reload_t1(self, path: str):
        sheet = self.cb_t1_sheet.currentText()
        if not sheet:
            return
        header = int(self.sp_t1_header.value())
        self.t1 = load_table(path, sheet, header)
        self.t1_df = self.t1.df
        self.cb_t1_key.clear()
        self.cb_t1_key.addItems(self.t1_df.columns.tolist())

    # ---------- build matcher ----------
    def _rebuild_multi_matcher(self):
        if self.t1_df is None:
            return

        sources_df: Dict[str, pd.DataFrame] = {}
        for sid, panel in self.sources.items():
            if panel.state.table is not None:
                sources_df[sid] = panel.state.table.df
            else:
                sources_df[sid] = pd.DataFrame()

        prof = MatchProfile(
            t1_fields=self.settings.t1_match_fields,
            src_fields=self.settings.src_match_fields,
        )

        if not prof.t1_fields or any(not prof.src_fields.get(sid) for sid in sources_df.keys()):
            # profile incomplete -> matcher disabled
            self.multi = None
            return

        self.multi = MultiMatcher(self.t1_df, sources_df, prof)

    # ---------- queue scan ----------
    def start_scan(self):
        if self.t1_df is None:
            QMessageBox.warning(self, "Fehlt", "Bitte zuerst Tabelle 1 laden.")
            return

        # build queue using key column (simple)
        key1 = self.cb_t1_key.currentText()
        if not key1:
            QMessageBox.warning(self, "Fehlt", "Bitte KEY-Spalte für Queue wählen.")
            return

        # For sources, we still allow independent file load inside SourcePanels
        # Rebuild matcher
        self._rebuild_multi_matcher()

        # queue: missing any non-key columns
        self.engine = MatchEngine(self.t1_df, key1, pd.DataFrame({key1: []}), key1)  # dummy df2
        cols = [c for c in self.engine.df1.columns if c not in [key1, "_KEY_"]]
        self.keys_queue = self.engine.keys_with_missing(cols)
        self.current_pos = -1

        self.status.setText(f"Queue: {len(self.keys_queue)} Datensätze mit Lücken")
        self.next_row()

    # ---------- navigation ----------
    def next_row(self):
        if not self.keys_queue:
            QMessageBox.information(self, "Fertig", "Keine fehlenden Datensätze gefunden.")
            return
        if self.current_pos < len(self.keys_queue) - 1:
            self.current_pos += 1
            key = self.keys_queue[self.current_pos]
            self._show_by_key(key)

    def prev_row(self):
        if not self.keys_queue:
            return
        if self.current_pos > 0:
            self.current_pos -= 1
            key = self.keys_queue[self.current_pos]
            self._show_by_key(key)

    # ---------- show ----------
    def _show_by_key(self, key_norm: str):
        # key_norm comes from MatchEngine _KEY_ (based on key column). Find T1 row index:
        hit = self.engine.df1.index[self.engine.df1["_KEY_"] == key_norm]
        if len(hit) == 0:
            return
        t1_idx = int(hit[0])
        self.current_t1_index = t1_idx

        self._render_t1_row(t1_idx)
        self._render_sources_for_t1(t1_idx)
        self._apply_header_colors()

        self.status.setText(f"Pos {self.current_pos+1}/{len(self.keys_queue)} | KEY={key_norm}")

    def _render_t1_row(self, t1_idx: int):
        df = self.t1_df
        row = df.loc[t1_idx]

        all_cols = [c for c in df.columns if c != "_KEY_"]
        self._t1_cols_top = all_cols[:20]
        self._t1_cols_bottom = all_cols[20:]

        def render(view, cols):
            view.blockSignals(True)
            view.setColumnCount(len(cols))
            view.setHorizontalHeaderLabels(cols)
            view.setRowCount(1)
            for i, col in enumerate(cols):
                view.setItem(0, i, QTableWidgetItem("" if row.get(col) is None else str(row.get(col))))
            view.blockSignals(False)

        render(self.t1_view_top, self._t1_cols_top)
        if len(all_cols) > 20:
            self.t1_view_bottom.show()
            render(self.t1_view_bottom, self._t1_cols_bottom)
        else:
            self.t1_view_bottom.hide()

        self.t1_view_top.setCurrentCell(0, 0)
        self._t1_last_focus = (self.t1_view_top, 0, 0)

    def _render_sources_for_t1(self, t1_idx: int):
        # If matcher not ready: show empty
        if self.multi is None:
            for sid, panel in self.sources.items():
                panel.render_rows(pd.DataFrame())
                self._apply_header_colors()
            return

        matches = self.multi.match_for_t1_index(t1_idx)  # sid -> [row_indices]
        for sid, panel in self.sources.items():
            if panel.state.table is None:
                panel.render_rows(pd.DataFrame())
                self._apply_header_colors()
                continue
            df = panel.state.table.df
            idxs = matches.get(sid, [])
            sub = df.loc[idxs] if idxs else df.iloc[0:0]
            panel.render_rows(sub.reset_index(drop=True))
            self._apply_header_colors()

    # ---------- T1 edit/drop sync ----------
    def on_t1_item_changed_any(self, item: QTableWidgetItem):
        if self.t1_df is None or self.current_t1_index is None:
            return
        view = item.tableWidget()

        if view == self.t1_view_top:
            col_name = self._t1_cols_top[item.column()]
        else:
            col_name = self._t1_cols_bottom[item.column()]

        self.t1_df.at[self.current_t1_index, col_name] = item.text()

    def on_t1_cell_dropped(self, view, row: int, col: int, text: str):
        # called by TargetTable (dnd_tables.py)
        if self.t1_df is None or self.current_t1_index is None:
            return
        if view == self.t1_view_top:
            col_name = self._t1_cols_top[col]
        else:
            col_name = self._t1_cols_bottom[col]
        self.t1_df.at[self.current_t1_index, col_name] = text

    # ---------- search T1 ----------
    def restore_t1_focus(self):
        if hasattr(self, "_t1_last_focus") and self._t1_last_focus:
            v, r, c = self._t1_last_focus
            v.setCurrentCell(r, c)
            v.setFocus()

    def search_t1_next(self):
        needle = self.ed_search_t1.text()
        if not needle:
            return
        views = [self.t1_view_top] + ([self.t1_view_bottom] if self.t1_view_bottom.isVisible() else [])

        # start from current
        start = (0, 0, -1)
        for vi, v in enumerate(views):
            if v.currentRow() >= 0 and v.currentColumn() >= 0 and v.hasFocus():
                start = (vi, v.currentRow(), v.currentColumn())
                break

        for vi in range(start[0], len(views)):
            v = views[vi]
            r0 = start[1] if vi == start[0] else 0
            for r in range(r0, v.rowCount()):
                c0 = start[2] + 1 if (vi == start[0] and r == r0) else 0
                for c in range(c0, v.columnCount()):
                    it = v.item(r, c)
                    if it and needle in it.text():
                        v.setCurrentCell(r, c)
                        v.setFocus()
                        self._t1_last_focus = (v, r, c)
                        return

    # ---------- match fields UI ----------
    def open_match_fields_dialog(self):
        if self.t1_df is None:
            QMessageBox.warning(self, "Fehlt", "Bitte zuerst Tabelle 1 laden.")
            return

        dlg = QDialog(self)
        dlg.setWindowTitle("Match-Felder (T1 ↔ Quellen)")
        root = QVBoxLayout(dlg)

        form = QFormLayout()
        root.addLayout(form)

        # T1 fields multi-select
        t1_list = QListWidget()
        t1_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        for c in self.t1_df.columns:
            it = QListWidgetItem(c)
            t1_list.addItem(it)
            if c in self.settings.t1_match_fields:
                it.setSelected(True)
        form.addRow(QLabel("T1 Match-Felder"), t1_list)

        # per source
        src_lists: Dict[str, QListWidget] = {}
        for st in self.src_states:
            panel = self.sources[st.src_id]
            df = panel.state.table.df if panel.state.table is not None else pd.DataFrame()
            lst = QListWidget()
            lst.setSelectionMode(QAbstractItemView.ExtendedSelection)
            for c in list(df.columns):
                it = QListWidgetItem(c)
                lst.addItem(it)
                if c in (self.settings.src_match_fields.get(st.src_id, []) or []):
                    it.setSelected(True)
            form.addRow(QLabel(f"{st.title} Match-Felder"), lst)
            src_lists[st.src_id] = lst

        btns = QHBoxLayout()
        okb = QPushButton("Speichern")
        cancel = QPushButton("Abbrechen")
        btns.addWidget(okb)
        btns.addWidget(cancel)
        root.addLayout(btns)

        def on_ok():
            self.settings.t1_match_fields = [i.text() for i in t1_list.selectedItems()]
            for sid, lst in src_lists.items():
                self.settings.src_match_fields[sid] = [i.text() for i in lst.selectedItems()]
            self._save_settings()
            self._rebuild_multi_matcher()
            # refresh current view
            if self.current_t1_index is not None:
                self._render_sources_for_t1(self.current_t1_index)
            dlg.accept()

        okb.clicked.connect(on_ok)
        cancel.clicked.connect(dlg.reject)
        dlg.exec()

    # ---------- save ----------
    def save_new_file(self):
        if self.t1 is None or self.t1_df is None:
            return
        out = save_filled(self.t1_df, self.t1.path.parent, self.t1.path.stem)
        QMessageBox.information(self, "Gespeichert", str(out))

    def save_as(self):
        if self.t1_df is None:
            return
        default = "output.xlsx"
        if self.t1:
            default = str(self.t1.path.with_name(self.t1.path.stem + "_filled.xlsx"))
        path, _ = QFileDialog.getSaveFileName(self, "Speichern unter…", default, "Excel (*.xlsx *.xls)")
        if not path:
            return
        out = save_to_path(self.t1_df, path)
        QMessageBox.information(self, "Gespeichert", str(out))

    def save_inplace(self):
        if self.t1 is None or self.t1_df is None:
            return
        try:
            out = save_in_place(self.t1_df, self.t1.path, self.t1.sheet, make_backup=True)
            QMessageBox.information(self, "Gespeichert", f"In Datei gespeichert (Backup erstellt):\n{out}")
        except PermissionError:
            QMessageBox.critical(self, "Fehler", "Datei ist vermutlich in Excel geöffnet. Bitte schließen und erneut speichern.")
        except Exception as e:
            QMessageBox.critical(self, "Fehler", f"Speichern fehlgeschlagen:\n{e}")

    # ---------- fills (placeholder: reuse your current coupling/cuts logic if needed) ----------
    #def autofill_current_row(self): def autofill_current_key_linked(self):
     # ---------------- Plausible fill row ----------------
    def autofill_current_row(self):
        if not self.engine or self.current_key is None:
            return

        t1_idx = self.engine.t1_row_index_for_key(self.current_key)
        if t1_idx is None:
            return

        t2_df = self.engine.t2_rows_for_key(self.current_key)
        if t2_df is None or len(t2_df) == 0:
            QMessageBox.information(self, "Auto-Fill", "Keine passende Kundennummer in Tabelle 2 gefunden.")
            return

        display_cols = [c for c in self.engine.df1.columns if c != "_KEY_"]
        key_col = self.cb_t1_key.currentText()

        filled = 0

        for t1_col in display_cols:
            if t1_col == key_col:
                continue
            if not is_missing(self.engine.df1.at[t1_idx, t1_col]):
                continue

            t2_col = self.col_links.get(t1_col)
            if not t2_col or t2_col not in t2_df.columns:
                continue

            chosen = None
            for _, r in t2_df.iterrows():
                v = r.get(t2_col)
                if not is_missing(v):
                    chosen = str(v).strip()
                    if chosen:
                        break
            if not chosen:
                continue

            if self.cuts.get("split_street_house", True) and t1_col.lower() in ("street", "straße"):
                street, house = split_street_house(chosen)
                chosen = street
                for cand in ("houseNumber", "hausnummer"):
                    if cand in self.engine.df1.columns and is_missing(self.engine.df1.at[t1_idx, cand]) and house:
                        self.engine.df1.at[t1_idx, cand] = house

            if self.cuts.get("normalize_phone", True) and t1_col.lower() in ("phone", "phonegeneral", "telefon", "festnetz", "mobil", "mobilgeneral"):
                chosen = normalize_phone(chosen)

            self.engine.df1.at[t1_idx, t1_col] = chosen
            filled += 1

        if self.cuts.get("fill_country_default", False) and "country" in self.engine.df1.columns and is_missing(self.engine.df1.at[t1_idx, "country"]):
            self.engine.df1.at[t1_idx, "country"] = self.country_default_value

        if self.cuts.get("infer_state_from_zip", False) and "state" in self.engine.df1.columns and is_missing(self.engine.df1.at[t1_idx, "state"]):
            z = None
            for cand in ("zipCode", "plz", "postalCode"):
                if cand in self.engine.df1.columns:
                    z = self.engine.df1.at[t1_idx, cand]
                    break
            st = state_from_zip_de(z) if z else None
            if st:
                self.engine.df1.at[t1_idx, "state"] = st

        self.show_key(self.current_key)
        QMessageBox.information(self, "Auto-Fill", f"{filled} Felder (Zeile) plausibel gefüllt.")

    # def autofill_all(self): def autofill_all_linked(self):
    # ---------------- Plausible fill all ----------------
    def autofill_all(self):
        if not self.engine:
            QMessageBox.warning(self, "Fehlt", "Bitte erst Start ausführen.")
            return
        if not self.col_links:
            QMessageBox.warning(self, "Fehlt", "Bitte erst Kopplungen definieren.")
            return

        key_col = self.cb_t1_key.currentText()
        total_filled = 0

        for idx, row in self.engine.df1.iterrows():
            key = row.get("_KEY_")
            if not key:
                continue

            t2_df = self.engine.t2_rows_for_key(key)
            if t2_df is None or len(t2_df) == 0:
                continue

            for t1_col, t2_col in self.col_links.items():
                if t1_col in ("_KEY_", key_col):
                    continue
                if t1_col not in self.engine.df1.columns or t2_col not in t2_df.columns:
                    continue
                if not is_missing(self.engine.df1.at[idx, t1_col]):
                    continue

                chosen = None
                for _, r2 in t2_df.iterrows():
                    v = r2.get(t2_col)
                    if not is_missing(v):
                        chosen = str(v).strip()
                        if chosen:
                            break
                if not chosen:
                    continue

                if self.cuts.get("normalize_phone", True) and t1_col.lower() in ("phone", "phonegeneral", "telefon", "festnetz", "mobil", "mobilgeneral"):
                    chosen = normalize_phone(chosen)

                self.engine.df1.at[idx, t1_col] = chosen
                total_filled += 1

                if self.cuts.get("split_street_house", True) and t1_col.lower() in ("street", "straße"):
                    street, house = split_street_house(chosen)
                    self.engine.df1.at[idx, t1_col] = street
                    for cand in ("houseNumber", "hausnummer"):
                        if cand in self.engine.df1.columns and is_missing(self.engine.df1.at[idx, cand]) and house:
                            self.engine.df1.at[idx, cand] = house

            if self.cuts.get("fill_country_default", False) and "country" in self.engine.df1.columns and is_missing(self.engine.df1.at[idx, "country"]):
                self.engine.df1.at[idx, "country"] = self.country_default_value

            if self.cuts.get("infer_state_from_zip", False) and "state" in self.engine.df1.columns and is_missing(self.engine.df1.at[idx, "state"]):
                z = None
                for cand in ("zipCode", "plz", "postalCode"):
                    if cand in self.engine.df1.columns:
                        z = self.engine.df1.at[idx, cand]
                        break
                st = state_from_zip_de(z) if z else None
                if st:
                    self.engine.df1.at[idx, "state"] = st

        if self.current_key is not None:
            self.show_key(self.current_key)

        QMessageBox.information(self, "Auto-Fill Gesamt", f"{total_filled} Zellen in der gesamten Tabelle gefüllt.")
